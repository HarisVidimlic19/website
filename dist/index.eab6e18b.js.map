{"mappings":"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","sources":["<anon>","src/js/popper.min.js","src/utils/isFunction.js","src/utils/getStyleComputedProperty.js","src/utils/getParentNode.js","src/utils/getScrollParent.js","src/utils/getOffsetParent.js","src/utils/isOffsetContainer.js","src/utils/getRoot.js","src/utils/findCommonOffsetParent.js","src/utils/getScroll.js","src/utils/includeScroll.js","src/utils/getBordersSize.js","src/utils/getWindowSizes.js","src/utils/getClientRect.js","src/utils/getBoundingClientRect.js","src/utils/getOffsetRectRelativeToArbitraryNode.js","src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","src/utils/isFixed.js","src/utils/getBoundaries.js","src/utils/computeAutoPlacement.js","src/utils/getReferenceOffsets.js","src/utils/getOuterSizes.js","src/utils/getOppositePlacement.js","src/utils/getPopperOffsets.js","src/utils/find.js","src/utils/findIndex.js","src/utils/runModifiers.js","src/methods/update.js","src/utils/isModifierEnabled.js","src/utils/getSupportedPropertyName.js","src/methods/destroy.js","src/utils/setupEventListeners.js","src/methods/enableEventListeners.js","src/utils/removeEventListeners.js","src/methods/disableEventListeners.js","src/utils/isNumeric.js","src/utils/setStyles.js","src/utils/setAttributes.js","src/utils/isModifierRequired.js","src/utils/getOppositeVariation.js","src/utils/clockwise.js","src/modifiers/offset.js","src/utils/debounce.js","src/modifiers/arrow.js","src/modifiers/computeStyle.js","src/utils/isNative.js","src/utils/isIE10.js","src/modifiers/flip.js","src/index.js","src/methods/defaults.js","src/modifiers/index.js","src/modifiers/shift.js","src/modifiers/preventOverflow.js","src/modifiers/keepTogether.js","src/modifiers/inner.js","src/modifiers/hide.js","src/modifiers/applyStyle.js"],"sourcesContent":["/*\r\n Copyright (C) Federico Zivolo 2017\r\n Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).\r\n */ (function(e, t) {\n    \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define(t) : e.Popper = t();\n})(this, function() {\n    \"use strict\";\n    function e(e) {\n        return e && \"[object Function]\" === ({}).toString.call(e);\n    }\n    function t(e, t) {\n        if (1 !== e.nodeType) return [];\n        var o = window.getComputedStyle(e, null);\n        return t ? o[t] : o;\n    }\n    function o(e) {\n        return \"HTML\" === e.nodeName ? e : e.parentNode || e.host;\n    }\n    function n(e) {\n        if (!e || -1 !== [\n            \"HTML\",\n            \"BODY\",\n            \"#document\"\n        ].indexOf(e.nodeName)) return window.document.body;\n        var i = t(e), r = i.overflow, p = i.overflowX, s = i.overflowY;\n        return /(auto|scroll)/.test(r + s + p) ? e : n(o(e));\n    }\n    function r(e) {\n        var o = e && e.offsetParent, i = o && o.nodeName;\n        return i && \"BODY\" !== i && \"HTML\" !== i ? -1 !== [\n            \"TD\",\n            \"TABLE\"\n        ].indexOf(o.nodeName) && \"static\" === t(o, \"position\") ? r(o) : o : window.document.documentElement;\n    }\n    function p(e) {\n        var t = e.nodeName;\n        return \"BODY\" !== t && (\"HTML\" === t || r(e.firstElementChild) === e);\n    }\n    function s(e) {\n        return null === e.parentNode ? e : s(e.parentNode);\n    }\n    function d(e, t) {\n        if (!e || !e.nodeType || !t || !t.nodeType) return window.document.documentElement;\n        var o = e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_FOLLOWING, i = o ? e : t, n = o ? t : e, a = document.createRange();\n        a.setStart(i, 0), a.setEnd(n, 0);\n        var f = a.commonAncestorContainer;\n        if (e !== f && t !== f || i.contains(n)) return p(f) ? f : r(f);\n        var l = s(e);\n        return l.host ? d(l.host, t) : d(e, s(t).host);\n    }\n    function a(e) {\n        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : \"top\", o = \"top\" === t ? \"scrollTop\" : \"scrollLeft\", i = e.nodeName;\n        if (\"BODY\" === i || \"HTML\" === i) {\n            var n = window.document.documentElement, r = window.document.scrollingElement || n;\n            return r[o];\n        }\n        return e[o];\n    }\n    function f(e, t) {\n        var o = 2 < arguments.length && void 0 !== arguments[2] && arguments[2], i = a(t, \"top\"), n = a(t, \"left\"), r = o ? -1 : 1;\n        return e.top += i * r, e.bottom += i * r, e.left += n * r, e.right += n * r, e;\n    }\n    function l(e, t) {\n        var o = \"x\" === t ? \"Left\" : \"Top\", i = \"Left\" == o ? \"Right\" : \"Bottom\";\n        return +e[\"border\" + o + \"Width\"].split(\"px\")[0] + +e[\"border\" + i + \"Width\"].split(\"px\")[0];\n    }\n    function m(e, t, o, i) {\n        return _(t[\"offset\" + e], o[\"client\" + e], o[\"offset\" + e], ie() ? o[\"offset\" + e] + i[\"margin\" + (\"Height\" === e ? \"Top\" : \"Left\")] + i[\"margin\" + (\"Height\" === e ? \"Bottom\" : \"Right\")] : 0);\n    }\n    function h() {\n        var e = window.document.body, t = window.document.documentElement, o = ie() && window.getComputedStyle(t);\n        return {\n            height: m(\"Height\", e, t, o),\n            width: m(\"Width\", e, t, o)\n        };\n    }\n    function c(e) {\n        return se({}, e, {\n            right: e.left + e.width,\n            bottom: e.top + e.height\n        });\n    }\n    function g(e) {\n        var o = {};\n        if (ie()) try {\n            o = e.getBoundingClientRect();\n            var i = a(e, \"top\"), n = a(e, \"left\");\n            o.top += i, o.left += n, o.bottom += i, o.right += n;\n        } catch (e) {}\n        else o = e.getBoundingClientRect();\n        var r = {\n            left: o.left,\n            top: o.top,\n            width: o.right - o.left,\n            height: o.bottom - o.top\n        }, p = \"HTML\" === e.nodeName ? h() : {}, s = p.width || e.clientWidth || r.right - r.left, d = p.height || e.clientHeight || r.bottom - r.top, f = e.offsetWidth - s, m = e.offsetHeight - d;\n        if (f || m) {\n            var g = t(e);\n            f -= l(g, \"x\"), m -= l(g, \"y\"), r.width -= f, r.height -= m;\n        }\n        return c(r);\n    }\n    function u(e, o) {\n        var i = ie(), r = \"HTML\" === o.nodeName, p = g(e), s = g(o), d = n(e), a = t(o), l = +a.borderTopWidth.split(\"px\")[0], m = +a.borderLeftWidth.split(\"px\")[0], h = c({\n            top: p.top - s.top - l,\n            left: p.left - s.left - m,\n            width: p.width,\n            height: p.height\n        });\n        if (h.marginTop = 0, h.marginLeft = 0, !i && r) {\n            var u = +a.marginTop.split(\"px\")[0], b = +a.marginLeft.split(\"px\")[0];\n            h.top -= l - u, h.bottom -= l - u, h.left -= m - b, h.right -= m - b, h.marginTop = u, h.marginLeft = b;\n        }\n        return (i ? o.contains(d) : o === d && \"BODY\" !== d.nodeName) && (h = f(h, o)), h;\n    }\n    function b(e) {\n        var t = window.document.documentElement, o = u(e, t), i = _(t.clientWidth, window.innerWidth || 0), n = _(t.clientHeight, window.innerHeight || 0), r = a(t), p = a(t, \"left\"), s = {\n            top: r - o.top + o.marginTop,\n            left: p - o.left + o.marginLeft,\n            width: i,\n            height: n\n        };\n        return c(s);\n    }\n    function y(e) {\n        var i = e.nodeName;\n        return \"BODY\" === i || \"HTML\" === i ? !1 : \"fixed\" === t(e, \"position\") || y(o(e));\n    }\n    function w(e, t, i, r) {\n        var p = {\n            top: 0,\n            left: 0\n        }, s = d(e, t);\n        if (\"viewport\" === r) p = b(s);\n        else {\n            var a;\n            \"scrollParent\" === r ? (a = n(o(e)), \"BODY\" === a.nodeName && (a = window.document.documentElement)) : \"window\" === r ? a = window.document.documentElement : a = r;\n            var f = u(a, s);\n            if (\"HTML\" === a.nodeName && !y(s)) {\n                var l = h(), m = l.height, c = l.width;\n                p.top += f.top - f.marginTop, p.bottom = m + f.top, p.left += f.left - f.marginLeft, p.right = c + f.left;\n            } else p = f;\n        }\n        return p.left += i, p.top += i, p.right -= i, p.bottom -= i, p;\n    }\n    function v(e) {\n        var t = e.width, o = e.height;\n        return t * o;\n    }\n    function E(e, t, o, i, n) {\n        var r = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0;\n        if (-1 === e.indexOf(\"auto\")) return e;\n        var p = w(o, i, r, n), s = {\n            top: {\n                width: p.width,\n                height: t.top - p.top\n            },\n            right: {\n                width: p.right - t.right,\n                height: p.height\n            },\n            bottom: {\n                width: p.width,\n                height: p.bottom - t.bottom\n            },\n            left: {\n                width: t.left - p.left,\n                height: p.height\n            }\n        }, d = Object.keys(s).map(function(e) {\n            return se({\n                key: e\n            }, s[e], {\n                area: v(s[e])\n            });\n        }).sort(function(e, t) {\n            return t.area - e.area;\n        }), a = d.filter(function(e) {\n            var t = e.width, i = e.height;\n            return t >= o.clientWidth && i >= o.clientHeight;\n        }), f = 0 < a.length ? a[0].key : d[0].key, l = e.split(\"-\")[1];\n        return f + (l ? \"-\" + l : \"\");\n    }\n    function x(e, t, o) {\n        var i = d(t, o);\n        return u(o, i);\n    }\n    function O(e) {\n        var t = window.getComputedStyle(e), o = parseFloat(t.marginTop) + parseFloat(t.marginBottom), i = parseFloat(t.marginLeft) + parseFloat(t.marginRight), n = {\n            width: e.offsetWidth + i,\n            height: e.offsetHeight + o\n        };\n        return n;\n    }\n    function L(e) {\n        var t = {\n            left: \"right\",\n            right: \"left\",\n            bottom: \"top\",\n            top: \"bottom\"\n        };\n        return e.replace(/left|right|bottom|top/g, function(e) {\n            return t[e];\n        });\n    }\n    function S(e, t, o) {\n        o = o.split(\"-\")[0];\n        var i = O(e), n = {\n            width: i.width,\n            height: i.height\n        }, r = -1 !== [\n            \"right\",\n            \"left\"\n        ].indexOf(o), p = r ? \"top\" : \"left\", s = r ? \"left\" : \"top\", d = r ? \"height\" : \"width\", a = r ? \"width\" : \"height\";\n        return n[p] = t[p] + t[d] / 2 - i[d] / 2, n[s] = o === s ? t[s] - i[a] : t[L(s)], n;\n    }\n    function T(e, t) {\n        return Array.prototype.find ? e.find(t) : e.filter(t)[0];\n    }\n    function C(e, t, o) {\n        if (Array.prototype.findIndex) return e.findIndex(function(e) {\n            return e[t] === o;\n        });\n        var i = T(e, function(e) {\n            return e[t] === o;\n        });\n        return e.indexOf(i);\n    }\n    function N(t, o, i) {\n        var n = void 0 === i ? t : t.slice(0, C(t, \"name\", i));\n        return n.forEach(function(t) {\n            t.function && console.warn(\"`modifier.function` is deprecated, use `modifier.fn`!\");\n            var i = t.function || t.fn;\n            t.enabled && e(i) && (o.offsets.popper = c(o.offsets.popper), o.offsets.reference = c(o.offsets.reference), o = i(o, t));\n        }), o;\n    }\n    function k() {\n        if (!this.state.isDestroyed) {\n            var e = {\n                instance: this,\n                styles: {},\n                attributes: {},\n                flipped: !1,\n                offsets: {}\n            };\n            e.offsets.reference = x(this.state, this.popper, this.reference), e.placement = E(this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.offsets.popper = S(this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = \"absolute\", e = N(this.modifiers, e), this.state.isCreated ? this.options.onUpdate(e) : (this.state.isCreated = !0, this.options.onCreate(e));\n        }\n    }\n    function W(e, t) {\n        return e.some(function(e) {\n            var o = e.name, i = e.enabled;\n            return i && o === t;\n        });\n    }\n    function B(e) {\n        for(var t = [\n            !1,\n            \"ms\",\n            \"Webkit\",\n            \"Moz\",\n            \"O\"\n        ], o = e.charAt(0).toUpperCase() + e.slice(1), n = 0; n < t.length - 1; n++){\n            var i = t[n], r = i ? \"\" + i + o : e;\n            if (\"undefined\" != typeof window.document.body.style[r]) return r;\n        }\n        return null;\n    }\n    function D() {\n        return this.state.isDestroyed = !0, W(this.modifiers, \"applyStyle\") && (this.popper.removeAttribute(\"x-placement\"), this.popper.style.left = \"\", this.popper.style.position = \"\", this.popper.style.top = \"\", this.popper.style[B(\"transform\")] = \"\"), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this;\n    }\n    function H(e, t, o, i) {\n        var r = \"BODY\" === e.nodeName, p = r ? window : e;\n        p.addEventListener(t, o, {\n            passive: !0\n        }), r || H(n(p.parentNode), t, o, i), i.push(p);\n    }\n    function P(e, t, o, i) {\n        o.updateBound = i, window.addEventListener(\"resize\", o.updateBound, {\n            passive: !0\n        });\n        var r = n(e);\n        return H(r, \"scroll\", o.updateBound, o.scrollParents), o.scrollElement = r, o.eventsEnabled = !0, o;\n    }\n    function A() {\n        this.state.eventsEnabled || (this.state = P(this.reference, this.options, this.state, this.scheduleUpdate));\n    }\n    function M(e, t) {\n        return window.removeEventListener(\"resize\", t.updateBound), t.scrollParents.forEach(function(e) {\n            e.removeEventListener(\"scroll\", t.updateBound);\n        }), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled = !1, t;\n    }\n    function I() {\n        this.state.eventsEnabled && (window.cancelAnimationFrame(this.scheduleUpdate), this.state = M(this.reference, this.state));\n    }\n    function R(e) {\n        return \"\" !== e && !isNaN(parseFloat(e)) && isFinite(e);\n    }\n    function U(e, t) {\n        Object.keys(t).forEach(function(o) {\n            var i = \"\";\n            -1 !== [\n                \"width\",\n                \"height\",\n                \"top\",\n                \"right\",\n                \"bottom\",\n                \"left\"\n            ].indexOf(o) && R(t[o]) && (i = \"px\"), e.style[o] = t[o] + i;\n        });\n    }\n    function Y(e, t) {\n        Object.keys(t).forEach(function(o) {\n            var i = t[o];\n            !1 === i ? e.removeAttribute(o) : e.setAttribute(o, t[o]);\n        });\n    }\n    function F(e, t, o) {\n        var i = T(e, function(e) {\n            var o = e.name;\n            return o === t;\n        }), n = !!i && e.some(function(e) {\n            return e.name === o && e.enabled && e.order < i.order;\n        });\n        if (!n) {\n            var r = \"`\" + t + \"`\";\n            console.warn(\"`\" + o + \"`\" + \" modifier is required by \" + r + \" modifier in order to work, be sure to include it before \" + r + \"!\");\n        }\n        return n;\n    }\n    function j(e) {\n        return \"end\" === e ? \"start\" : \"start\" === e ? \"end\" : e;\n    }\n    function K(e) {\n        var t = 1 < arguments.length && void 0 !== arguments[1] && arguments[1], o = ae.indexOf(e), i = ae.slice(o + 1).concat(ae.slice(0, o));\n        return t ? i.reverse() : i;\n    }\n    function q(e, t, o, i) {\n        var n = e.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/), r = +n[1], p = n[2];\n        if (!r) return e;\n        if (0 === p.indexOf(\"%\")) {\n            var s;\n            switch(p){\n                case \"%p\":\n                    s = o;\n                    break;\n                case \"%\":\n                case \"%r\":\n                default:\n                    s = i;\n            }\n            var d = c(s);\n            return d[t] / 100 * r;\n        }\n        if (\"vh\" === p || \"vw\" === p) {\n            var a;\n            return a = \"vh\" === p ? _(document.documentElement.clientHeight, window.innerHeight || 0) : _(document.documentElement.clientWidth, window.innerWidth || 0), a / 100 * r;\n        }\n        return r;\n    }\n    function G(e, t, o, i) {\n        var n = [\n            0,\n            0\n        ], r = -1 !== [\n            \"right\",\n            \"left\"\n        ].indexOf(i), p = e.split(/(\\+|\\-)/).map(function(e) {\n            return e.trim();\n        }), s = p.indexOf(T(p, function(e) {\n            return -1 !== e.search(/,|\\s/);\n        }));\n        p[s] && -1 === p[s].indexOf(\",\") && console.warn(\"Offsets separated by white space(s) are deprecated, use a comma (,) instead.\");\n        var d = /\\s*,\\s*|\\s+/, a = -1 === s ? [\n            p\n        ] : [\n            p.slice(0, s).concat([\n                p[s].split(d)[0]\n            ]),\n            [\n                p[s].split(d)[1]\n            ].concat(p.slice(s + 1))\n        ];\n        return a = a.map(function(e, i) {\n            var n = (1 === i ? !r : r) ? \"height\" : \"width\", p = !1;\n            return e.reduce(function(e, t) {\n                return \"\" === e[e.length - 1] && -1 !== [\n                    \"+\",\n                    \"-\"\n                ].indexOf(t) ? (e[e.length - 1] = t, p = !0, e) : p ? (e[e.length - 1] += t, p = !1, e) : e.concat(t);\n            }, []).map(function(e) {\n                return q(e, n, t, o);\n            });\n        }), a.forEach(function(e, t) {\n            e.forEach(function(o, i) {\n                R(o) && (n[t] += o * (\"-\" === e[i - 1] ? -1 : 1));\n            });\n        }), n;\n    }\n    for(var z = Math.min, V = Math.floor, _ = Math.max, X = [\n        \"native code\",\n        \"[object MutationObserverConstructor]\"\n    ], Q = function(e) {\n        return X.some(function(t) {\n            return -1 < (e || \"\").toString().indexOf(t);\n        });\n    }, J = \"undefined\" != typeof window, Z = [\n        \"Edge\",\n        \"Trident\",\n        \"Firefox\"\n    ], $ = 0, ee = 0; ee < Z.length; ee += 1)if (J && 0 <= navigator.userAgent.indexOf(Z[ee])) {\n        $ = 1;\n        break;\n    }\n    var i, te = J && Q(window.MutationObserver), oe = te ? function(e) {\n        var t = !1, o = 0, i = document.createElement(\"span\"), n = new MutationObserver(function() {\n            e(), t = !1;\n        });\n        return n.observe(i, {\n            attributes: !0\n        }), function() {\n            t || (t = !0, i.setAttribute(\"x-index\", o), ++o);\n        };\n    } : function(e) {\n        var t = !1;\n        return function() {\n            t || (t = !0, setTimeout(function() {\n                t = !1, e();\n            }, $));\n        };\n    }, ie = function() {\n        return void 0 == i && (i = -1 !== navigator.appVersion.indexOf(\"MSIE 10\")), i;\n    }, ne = function(e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    }, re = function() {\n        function e(e, t) {\n            for(var o, n = 0; n < t.length; n++)o = t[n], o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n        }\n        return function(t, o, i) {\n            return o && e(t.prototype, o), i && e(t, i), t;\n        };\n    }(), pe = function(e, t, o) {\n        return t in e ? Object.defineProperty(e, t, {\n            value: o,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n        }) : e[t] = o, e;\n    }, se = Object.assign || function(e) {\n        for(var t, o = 1; o < arguments.length; o++)for(var i in t = arguments[o], t)Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);\n        return e;\n    }, de = [\n        \"auto-start\",\n        \"auto\",\n        \"auto-end\",\n        \"top-start\",\n        \"top\",\n        \"top-end\",\n        \"right-start\",\n        \"right\",\n        \"right-end\",\n        \"bottom-end\",\n        \"bottom\",\n        \"bottom-start\",\n        \"left-end\",\n        \"left\",\n        \"left-start\"\n    ], ae = de.slice(3), fe = {\n        FLIP: \"flip\",\n        CLOCKWISE: \"clockwise\",\n        COUNTERCLOCKWISE: \"counterclockwise\"\n    }, le = function() {\n        function t(o, i) {\n            var n = this, r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};\n            ne(this, t), this.scheduleUpdate = function() {\n                return requestAnimationFrame(n.update);\n            }, this.update = oe(this.update.bind(this)), this.options = se({}, t.Defaults, r), this.state = {\n                isDestroyed: !1,\n                isCreated: !1,\n                scrollParents: []\n            }, this.reference = o.jquery ? o[0] : o, this.popper = i.jquery ? i[0] : i, this.options.modifiers = {}, Object.keys(se({}, t.Defaults.modifiers, r.modifiers)).forEach(function(e) {\n                n.options.modifiers[e] = se({}, t.Defaults.modifiers[e] || {}, r.modifiers ? r.modifiers[e] : {});\n            }), this.modifiers = Object.keys(this.options.modifiers).map(function(e) {\n                return se({\n                    name: e\n                }, n.options.modifiers[e]);\n            }).sort(function(e, t) {\n                return e.order - t.order;\n            }), this.modifiers.forEach(function(t) {\n                t.enabled && e(t.onLoad) && t.onLoad(n.reference, n.popper, n.options, t, n.state);\n            }), this.update();\n            var p = this.options.eventsEnabled;\n            p && this.enableEventListeners(), this.state.eventsEnabled = p;\n        }\n        return re(t, [\n            {\n                key: \"update\",\n                value: function() {\n                    return k.call(this);\n                }\n            },\n            {\n                key: \"destroy\",\n                value: function() {\n                    return D.call(this);\n                }\n            },\n            {\n                key: \"enableEventListeners\",\n                value: function() {\n                    return A.call(this);\n                }\n            },\n            {\n                key: \"disableEventListeners\",\n                value: function() {\n                    return I.call(this);\n                }\n            }\n        ]), t;\n    }();\n    return le.Utils = (\"undefined\" == typeof window ? global : window).PopperUtils, le.placements = de, le.Defaults = {\n        placement: \"bottom\",\n        eventsEnabled: !0,\n        removeOnDestroy: !1,\n        onCreate: function() {},\n        onUpdate: function() {},\n        modifiers: {\n            shift: {\n                order: 100,\n                enabled: !0,\n                fn: function(e) {\n                    var t = e.placement, o = t.split(\"-\")[0], i = t.split(\"-\")[1];\n                    if (i) {\n                        var n = e.offsets, r = n.reference, p = n.popper, s = -1 !== [\n                            \"bottom\",\n                            \"top\"\n                        ].indexOf(o), d = s ? \"left\" : \"top\", a = s ? \"width\" : \"height\", f = {\n                            start: pe({}, d, r[d]),\n                            end: pe({}, d, r[d] + r[a] - p[a])\n                        };\n                        e.offsets.popper = se({}, p, f[i]);\n                    }\n                    return e;\n                }\n            },\n            offset: {\n                order: 200,\n                enabled: !0,\n                fn: function(e, t) {\n                    var o, i = t.offset, n = e.placement, r = e.offsets, p = r.popper, s = r.reference, d = n.split(\"-\")[0];\n                    return o = R(+i) ? [\n                        +i,\n                        0\n                    ] : G(i, p, s, d), \"left\" === d ? (p.top += o[0], p.left -= o[1]) : \"right\" === d ? (p.top += o[0], p.left += o[1]) : \"top\" === d ? (p.left += o[0], p.top -= o[1]) : \"bottom\" === d && (p.left += o[0], p.top += o[1]), e.popper = p, e;\n                },\n                offset: 0\n            },\n            preventOverflow: {\n                order: 300,\n                enabled: !0,\n                fn: function(e, t) {\n                    var o = t.boundariesElement || r(e.instance.popper);\n                    e.instance.reference === o && (o = r(o));\n                    var i = w(e.instance.popper, e.instance.reference, t.padding, o);\n                    t.boundaries = i;\n                    var n = t.priority, p = e.offsets.popper, s = {\n                        primary: function(e) {\n                            var o = p[e];\n                            return p[e] < i[e] && !t.escapeWithReference && (o = _(p[e], i[e])), pe({}, e, o);\n                        },\n                        secondary: function(e) {\n                            var o = \"right\" === e ? \"left\" : \"top\", n = p[o];\n                            return p[e] > i[e] && !t.escapeWithReference && (n = z(p[o], i[e] - (\"right\" === e ? p.width : p.height))), pe({}, o, n);\n                        }\n                    };\n                    return n.forEach(function(e) {\n                        var t = -1 === [\n                            \"left\",\n                            \"top\"\n                        ].indexOf(e) ? \"secondary\" : \"primary\";\n                        p = se({}, p, s[t](e));\n                    }), e.offsets.popper = p, e;\n                },\n                priority: [\n                    \"left\",\n                    \"right\",\n                    \"top\",\n                    \"bottom\"\n                ],\n                padding: 5,\n                boundariesElement: \"scrollParent\"\n            },\n            keepTogether: {\n                order: 400,\n                enabled: !0,\n                fn: function(e) {\n                    var t = e.offsets, o = t.popper, i = t.reference, n = e.placement.split(\"-\")[0], r = V, p = -1 !== [\n                        \"top\",\n                        \"bottom\"\n                    ].indexOf(n), s = p ? \"right\" : \"bottom\", d = p ? \"left\" : \"top\", a = p ? \"width\" : \"height\";\n                    return o[s] < r(i[d]) && (e.offsets.popper[d] = r(i[d]) - o[a]), o[d] > r(i[s]) && (e.offsets.popper[d] = r(i[s])), e;\n                }\n            },\n            arrow: {\n                order: 500,\n                enabled: !0,\n                fn: function(e, t) {\n                    if (!F(e.instance.modifiers, \"arrow\", \"keepTogether\")) return e;\n                    var o = t.element;\n                    if (\"string\" == typeof o) {\n                        if (o = e.instance.popper.querySelector(o), !o) return e;\n                    } else if (!e.instance.popper.contains(o)) return console.warn(\"WARNING: `arrow.element` must be child of its popper element!\"), e;\n                    var i = e.placement.split(\"-\")[0], n = e.offsets, r = n.popper, p = n.reference, s = -1 !== [\n                        \"left\",\n                        \"right\"\n                    ].indexOf(i), d = s ? \"height\" : \"width\", a = s ? \"top\" : \"left\", f = s ? \"left\" : \"top\", l = s ? \"bottom\" : \"right\", m = O(o)[d];\n                    p[l] - m < r[a] && (e.offsets.popper[a] -= r[a] - (p[l] - m)), p[a] + m > r[l] && (e.offsets.popper[a] += p[a] + m - r[l]);\n                    var h = p[a] + p[d] / 2 - m / 2, g = h - c(e.offsets.popper)[a];\n                    return g = _(z(r[d] - m, g), 0), e.arrowElement = o, e.offsets.arrow = {}, e.offsets.arrow[a] = Math.round(g), e.offsets.arrow[f] = \"\", e;\n                },\n                element: \"[x-arrow]\"\n            },\n            flip: {\n                order: 600,\n                enabled: !0,\n                fn: function(e, t) {\n                    if (W(e.instance.modifiers, \"inner\")) return e;\n                    if (e.flipped && e.placement === e.originalPlacement) return e;\n                    var o = w(e.instance.popper, e.instance.reference, t.padding, t.boundariesElement), i = e.placement.split(\"-\")[0], n = L(i), r = e.placement.split(\"-\")[1] || \"\", p = [];\n                    switch(t.behavior){\n                        case fe.FLIP:\n                            p = [\n                                i,\n                                n\n                            ];\n                            break;\n                        case fe.CLOCKWISE:\n                            p = K(i);\n                            break;\n                        case fe.COUNTERCLOCKWISE:\n                            p = K(i, !0);\n                            break;\n                        default:\n                            p = t.behavior;\n                    }\n                    return p.forEach(function(s, d) {\n                        if (i !== s || p.length === d + 1) return e;\n                        i = e.placement.split(\"-\")[0], n = L(i);\n                        var a = e.offsets.popper, f = e.offsets.reference, l = V, m = \"left\" === i && l(a.right) > l(f.left) || \"right\" === i && l(a.left) < l(f.right) || \"top\" === i && l(a.bottom) > l(f.top) || \"bottom\" === i && l(a.top) < l(f.bottom), h = l(a.left) < l(o.left), c = l(a.right) > l(o.right), g = l(a.top) < l(o.top), u = l(a.bottom) > l(o.bottom), b = \"left\" === i && h || \"right\" === i && c || \"top\" === i && g || \"bottom\" === i && u, y = -1 !== [\n                            \"top\",\n                            \"bottom\"\n                        ].indexOf(i), w = !!t.flipVariations && (y && \"start\" === r && h || y && \"end\" === r && c || !y && \"start\" === r && g || !y && \"end\" === r && u);\n                        (m || b || w) && (e.flipped = !0, (m || b) && (i = p[d + 1]), w && (r = j(r)), e.placement = i + (r ? \"-\" + r : \"\"), e.offsets.popper = se({}, e.offsets.popper, S(e.instance.popper, e.offsets.reference, e.placement)), e = N(e.instance.modifiers, e, \"flip\"));\n                    }), e;\n                },\n                behavior: \"flip\",\n                padding: 5,\n                boundariesElement: \"viewport\"\n            },\n            inner: {\n                order: 700,\n                enabled: !1,\n                fn: function(e) {\n                    var t = e.placement, o = t.split(\"-\")[0], i = e.offsets, n = i.popper, r = i.reference, p = -1 !== [\n                        \"left\",\n                        \"right\"\n                    ].indexOf(o), s = -1 === [\n                        \"top\",\n                        \"left\"\n                    ].indexOf(o);\n                    return n[p ? \"left\" : \"top\"] = r[t] - (s ? n[p ? \"width\" : \"height\"] : 0), e.placement = L(t), e.offsets.popper = c(n), e;\n                }\n            },\n            hide: {\n                order: 800,\n                enabled: !0,\n                fn: function(e) {\n                    if (!F(e.instance.modifiers, \"hide\", \"preventOverflow\")) return e;\n                    var t = e.offsets.reference, o = T(e.instance.modifiers, function(e) {\n                        return \"preventOverflow\" === e.name;\n                    }).boundaries;\n                    if (t.bottom < o.top || t.left > o.right || t.top > o.bottom || t.right < o.left) {\n                        if (!0 === e.hide) return e;\n                        e.hide = !0, e.attributes[\"x-out-of-boundaries\"] = \"\";\n                    } else {\n                        if (!1 === e.hide) return e;\n                        e.hide = !1, e.attributes[\"x-out-of-boundaries\"] = !1;\n                    }\n                    return e;\n                }\n            },\n            computeStyle: {\n                order: 850,\n                enabled: !0,\n                fn: function(e, t) {\n                    var o = t.x, i = t.y, n = e.offsets.popper, p = T(e.instance.modifiers, function(e) {\n                        return \"applyStyle\" === e.name;\n                    }).gpuAcceleration;\n                    void 0 !== p && console.warn(\"WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!\");\n                    var s, d, a = void 0 === p ? t.gpuAcceleration : p, f = r(e.instance.popper), l = g(f), m = {\n                        position: n.position\n                    }, h = {\n                        left: V(n.left),\n                        top: V(n.top),\n                        bottom: V(n.bottom),\n                        right: V(n.right)\n                    }, c = \"bottom\" === o ? \"top\" : \"bottom\", u = \"right\" === i ? \"left\" : \"right\", b = B(\"transform\");\n                    if (d = \"bottom\" == c ? -l.height + h.bottom : h.top, s = \"right\" == u ? -l.width + h.right : h.left, a && b) m[b] = \"translate3d(\" + s + \"px, \" + d + \"px, 0)\", m[c] = 0, m[u] = 0, m.willChange = \"transform\";\n                    else {\n                        var y = \"bottom\" == c ? -1 : 1, w = \"right\" == u ? -1 : 1;\n                        m[c] = d * y, m[u] = s * w, m.willChange = c + \", \" + u;\n                    }\n                    var v = {\n                        \"x-placement\": e.placement\n                    };\n                    return e.attributes = se({}, v, e.attributes), e.styles = se({}, m, e.styles), e;\n                },\n                gpuAcceleration: !0,\n                x: \"bottom\",\n                y: \"right\"\n            },\n            applyStyle: {\n                order: 900,\n                enabled: !0,\n                fn: function(e) {\n                    return U(e.instance.popper, e.styles), Y(e.instance.popper, e.attributes), e.offsets.arrow && U(e.arrowElement, e.offsets.arrow), e;\n                },\n                onLoad: function(e, t, o, i, n) {\n                    var r = x(n, t, e), p = E(o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding);\n                    return t.setAttribute(\"x-placement\", p), U(t, {\n                        position: \"absolute\"\n                    }), o;\n                },\n                gpuAcceleration: void 0\n            }\n        }\n    }, le;\n});\n\n//# sourceMappingURL=index.eab6e18b.js.map\n","/*\r\n Copyright (C) Federico Zivolo 2017\r\n Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).\r\n */(function(e,t){'object'==typeof exports&&'undefined'!=typeof module?module.exports=t():'function'==typeof define&&define.amd?define(t):e.Popper=t()})(this,function(){'use strict';function e(e){return e&&'[object Function]'==={}.toString.call(e)}function t(e,t){if(1!==e.nodeType)return[];var o=window.getComputedStyle(e,null);return t?o[t]:o}function o(e){return'HTML'===e.nodeName?e:e.parentNode||e.host}function n(e){if(!e||-1!==['HTML','BODY','#document'].indexOf(e.nodeName))return window.document.body;var i=t(e),r=i.overflow,p=i.overflowX,s=i.overflowY;return /(auto|scroll)/.test(r+s+p)?e:n(o(e))}function r(e){var o=e&&e.offsetParent,i=o&&o.nodeName;return i&&'BODY'!==i&&'HTML'!==i?-1!==['TD','TABLE'].indexOf(o.nodeName)&&'static'===t(o,'position')?r(o):o:window.document.documentElement}function p(e){var t=e.nodeName;return'BODY'!==t&&('HTML'===t||r(e.firstElementChild)===e)}function s(e){return null===e.parentNode?e:s(e.parentNode)}function d(e,t){if(!e||!e.nodeType||!t||!t.nodeType)return window.document.documentElement;var o=e.compareDocumentPosition(t)&Node.DOCUMENT_POSITION_FOLLOWING,i=o?e:t,n=o?t:e,a=document.createRange();a.setStart(i,0),a.setEnd(n,0);var f=a.commonAncestorContainer;if(e!==f&&t!==f||i.contains(n))return p(f)?f:r(f);var l=s(e);return l.host?d(l.host,t):d(e,s(t).host)}function a(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:'top',o='top'===t?'scrollTop':'scrollLeft',i=e.nodeName;if('BODY'===i||'HTML'===i){var n=window.document.documentElement,r=window.document.scrollingElement||n;return r[o]}return e[o]}function f(e,t){var o=2<arguments.length&&void 0!==arguments[2]&&arguments[2],i=a(t,'top'),n=a(t,'left'),r=o?-1:1;return e.top+=i*r,e.bottom+=i*r,e.left+=n*r,e.right+=n*r,e}function l(e,t){var o='x'===t?'Left':'Top',i='Left'==o?'Right':'Bottom';return+e['border'+o+'Width'].split('px')[0]+ +e['border'+i+'Width'].split('px')[0]}function m(e,t,o,i){return _(t['offset'+e],o['client'+e],o['offset'+e],ie()?o['offset'+e]+i['margin'+('Height'===e?'Top':'Left')]+i['margin'+('Height'===e?'Bottom':'Right')]:0)}function h(){var e=window.document.body,t=window.document.documentElement,o=ie()&&window.getComputedStyle(t);return{height:m('Height',e,t,o),width:m('Width',e,t,o)}}function c(e){return se({},e,{right:e.left+e.width,bottom:e.top+e.height})}function g(e){var o={};if(ie())try{o=e.getBoundingClientRect();var i=a(e,'top'),n=a(e,'left');o.top+=i,o.left+=n,o.bottom+=i,o.right+=n}catch(e){}else o=e.getBoundingClientRect();var r={left:o.left,top:o.top,width:o.right-o.left,height:o.bottom-o.top},p='HTML'===e.nodeName?h():{},s=p.width||e.clientWidth||r.right-r.left,d=p.height||e.clientHeight||r.bottom-r.top,f=e.offsetWidth-s,m=e.offsetHeight-d;if(f||m){var g=t(e);f-=l(g,'x'),m-=l(g,'y'),r.width-=f,r.height-=m}return c(r)}function u(e,o){var i=ie(),r='HTML'===o.nodeName,p=g(e),s=g(o),d=n(e),a=t(o),l=+a.borderTopWidth.split('px')[0],m=+a.borderLeftWidth.split('px')[0],h=c({top:p.top-s.top-l,left:p.left-s.left-m,width:p.width,height:p.height});if(h.marginTop=0,h.marginLeft=0,!i&&r){var u=+a.marginTop.split('px')[0],b=+a.marginLeft.split('px')[0];h.top-=l-u,h.bottom-=l-u,h.left-=m-b,h.right-=m-b,h.marginTop=u,h.marginLeft=b}return(i?o.contains(d):o===d&&'BODY'!==d.nodeName)&&(h=f(h,o)),h}function b(e){var t=window.document.documentElement,o=u(e,t),i=_(t.clientWidth,window.innerWidth||0),n=_(t.clientHeight,window.innerHeight||0),r=a(t),p=a(t,'left'),s={top:r-o.top+o.marginTop,left:p-o.left+o.marginLeft,width:i,height:n};return c(s)}function y(e){var i=e.nodeName;return'BODY'===i||'HTML'===i?!1:'fixed'===t(e,'position')||y(o(e))}function w(e,t,i,r){var p={top:0,left:0},s=d(e,t);if('viewport'===r)p=b(s);else{var a;'scrollParent'===r?(a=n(o(e)),'BODY'===a.nodeName&&(a=window.document.documentElement)):'window'===r?a=window.document.documentElement:a=r;var f=u(a,s);if('HTML'===a.nodeName&&!y(s)){var l=h(),m=l.height,c=l.width;p.top+=f.top-f.marginTop,p.bottom=m+f.top,p.left+=f.left-f.marginLeft,p.right=c+f.left}else p=f}return p.left+=i,p.top+=i,p.right-=i,p.bottom-=i,p}function v(e){var t=e.width,o=e.height;return t*o}function E(e,t,o,i,n){var r=5<arguments.length&&void 0!==arguments[5]?arguments[5]:0;if(-1===e.indexOf('auto'))return e;var p=w(o,i,r,n),s={top:{width:p.width,height:t.top-p.top},right:{width:p.right-t.right,height:p.height},bottom:{width:p.width,height:p.bottom-t.bottom},left:{width:t.left-p.left,height:p.height}},d=Object.keys(s).map(function(e){return se({key:e},s[e],{area:v(s[e])})}).sort(function(e,t){return t.area-e.area}),a=d.filter(function(e){var t=e.width,i=e.height;return t>=o.clientWidth&&i>=o.clientHeight}),f=0<a.length?a[0].key:d[0].key,l=e.split('-')[1];return f+(l?'-'+l:'')}function x(e,t,o){var i=d(t,o);return u(o,i)}function O(e){var t=window.getComputedStyle(e),o=parseFloat(t.marginTop)+parseFloat(t.marginBottom),i=parseFloat(t.marginLeft)+parseFloat(t.marginRight),n={width:e.offsetWidth+i,height:e.offsetHeight+o};return n}function L(e){var t={left:'right',right:'left',bottom:'top',top:'bottom'};return e.replace(/left|right|bottom|top/g,function(e){return t[e]})}function S(e,t,o){o=o.split('-')[0];var i=O(e),n={width:i.width,height:i.height},r=-1!==['right','left'].indexOf(o),p=r?'top':'left',s=r?'left':'top',d=r?'height':'width',a=r?'width':'height';return n[p]=t[p]+t[d]/2-i[d]/2,n[s]=o===s?t[s]-i[a]:t[L(s)],n}function T(e,t){return Array.prototype.find?e.find(t):e.filter(t)[0]}function C(e,t,o){if(Array.prototype.findIndex)return e.findIndex(function(e){return e[t]===o});var i=T(e,function(e){return e[t]===o});return e.indexOf(i)}function N(t,o,i){var n=void 0===i?t:t.slice(0,C(t,'name',i));return n.forEach(function(t){t.function&&console.warn('`modifier.function` is deprecated, use `modifier.fn`!');var i=t.function||t.fn;t.enabled&&e(i)&&(o.offsets.popper=c(o.offsets.popper),o.offsets.reference=c(o.offsets.reference),o=i(o,t))}),o}function k(){if(!this.state.isDestroyed){var e={instance:this,styles:{},attributes:{},flipped:!1,offsets:{}};e.offsets.reference=x(this.state,this.popper,this.reference),e.placement=E(this.options.placement,e.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),e.originalPlacement=e.placement,e.offsets.popper=S(this.popper,e.offsets.reference,e.placement),e.offsets.popper.position='absolute',e=N(this.modifiers,e),this.state.isCreated?this.options.onUpdate(e):(this.state.isCreated=!0,this.options.onCreate(e))}}function W(e,t){return e.some(function(e){var o=e.name,i=e.enabled;return i&&o===t})}function B(e){for(var t=[!1,'ms','Webkit','Moz','O'],o=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<t.length-1;n++){var i=t[n],r=i?''+i+o:e;if('undefined'!=typeof window.document.body.style[r])return r}return null}function D(){return this.state.isDestroyed=!0,W(this.modifiers,'applyStyle')&&(this.popper.removeAttribute('x-placement'),this.popper.style.left='',this.popper.style.position='',this.popper.style.top='',this.popper.style[B('transform')]=''),this.disableEventListeners(),this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}function H(e,t,o,i){var r='BODY'===e.nodeName,p=r?window:e;p.addEventListener(t,o,{passive:!0}),r||H(n(p.parentNode),t,o,i),i.push(p)}function P(e,t,o,i){o.updateBound=i,window.addEventListener('resize',o.updateBound,{passive:!0});var r=n(e);return H(r,'scroll',o.updateBound,o.scrollParents),o.scrollElement=r,o.eventsEnabled=!0,o}function A(){this.state.eventsEnabled||(this.state=P(this.reference,this.options,this.state,this.scheduleUpdate))}function M(e,t){return window.removeEventListener('resize',t.updateBound),t.scrollParents.forEach(function(e){e.removeEventListener('scroll',t.updateBound)}),t.updateBound=null,t.scrollParents=[],t.scrollElement=null,t.eventsEnabled=!1,t}function I(){this.state.eventsEnabled&&(window.cancelAnimationFrame(this.scheduleUpdate),this.state=M(this.reference,this.state))}function R(e){return''!==e&&!isNaN(parseFloat(e))&&isFinite(e)}function U(e,t){Object.keys(t).forEach(function(o){var i='';-1!==['width','height','top','right','bottom','left'].indexOf(o)&&R(t[o])&&(i='px'),e.style[o]=t[o]+i})}function Y(e,t){Object.keys(t).forEach(function(o){var i=t[o];!1===i?e.removeAttribute(o):e.setAttribute(o,t[o])})}function F(e,t,o){var i=T(e,function(e){var o=e.name;return o===t}),n=!!i&&e.some(function(e){return e.name===o&&e.enabled&&e.order<i.order});if(!n){var r='`'+t+'`';console.warn('`'+o+'`'+' modifier is required by '+r+' modifier in order to work, be sure to include it before '+r+'!')}return n}function j(e){return'end'===e?'start':'start'===e?'end':e}function K(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1],o=ae.indexOf(e),i=ae.slice(o+1).concat(ae.slice(0,o));return t?i.reverse():i}function q(e,t,o,i){var n=e.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/),r=+n[1],p=n[2];if(!r)return e;if(0===p.indexOf('%')){var s;switch(p){case'%p':s=o;break;case'%':case'%r':default:s=i;}var d=c(s);return d[t]/100*r}if('vh'===p||'vw'===p){var a;return a='vh'===p?_(document.documentElement.clientHeight,window.innerHeight||0):_(document.documentElement.clientWidth,window.innerWidth||0),a/100*r}return r}function G(e,t,o,i){var n=[0,0],r=-1!==['right','left'].indexOf(i),p=e.split(/(\\+|\\-)/).map(function(e){return e.trim()}),s=p.indexOf(T(p,function(e){return-1!==e.search(/,|\\s/)}));p[s]&&-1===p[s].indexOf(',')&&console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');var d=/\\s*,\\s*|\\s+/,a=-1===s?[p]:[p.slice(0,s).concat([p[s].split(d)[0]]),[p[s].split(d)[1]].concat(p.slice(s+1))];return a=a.map(function(e,i){var n=(1===i?!r:r)?'height':'width',p=!1;return e.reduce(function(e,t){return''===e[e.length-1]&&-1!==['+','-'].indexOf(t)?(e[e.length-1]=t,p=!0,e):p?(e[e.length-1]+=t,p=!1,e):e.concat(t)},[]).map(function(e){return q(e,n,t,o)})}),a.forEach(function(e,t){e.forEach(function(o,i){R(o)&&(n[t]+=o*('-'===e[i-1]?-1:1))})}),n}for(var z=Math.min,V=Math.floor,_=Math.max,X=['native code','[object MutationObserverConstructor]'],Q=function(e){return X.some(function(t){return-1<(e||'').toString().indexOf(t)})},J='undefined'!=typeof window,Z=['Edge','Trident','Firefox'],$=0,ee=0;ee<Z.length;ee+=1)if(J&&0<=navigator.userAgent.indexOf(Z[ee])){$=1;break}var i,te=J&&Q(window.MutationObserver),oe=te?function(e){var t=!1,o=0,i=document.createElement('span'),n=new MutationObserver(function(){e(),t=!1});return n.observe(i,{attributes:!0}),function(){t||(t=!0,i.setAttribute('x-index',o),++o)}}:function(e){var t=!1;return function(){t||(t=!0,setTimeout(function(){t=!1,e()},$))}},ie=function(){return void 0==i&&(i=-1!==navigator.appVersion.indexOf('MSIE 10')),i},ne=function(e,t){if(!(e instanceof t))throw new TypeError('Cannot call a class as a function')},re=function(){function e(e,t){for(var o,n=0;n<t.length;n++)o=t[n],o.enumerable=o.enumerable||!1,o.configurable=!0,'value'in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}return function(t,o,i){return o&&e(t.prototype,o),i&&e(t,i),t}}(),pe=function(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e},se=Object.assign||function(e){for(var t,o=1;o<arguments.length;o++)for(var i in t=arguments[o],t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e},de=['auto-start','auto','auto-end','top-start','top','top-end','right-start','right','right-end','bottom-end','bottom','bottom-start','left-end','left','left-start'],ae=de.slice(3),fe={FLIP:'flip',CLOCKWISE:'clockwise',COUNTERCLOCKWISE:'counterclockwise'},le=function(){function t(o,i){var n=this,r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};ne(this,t),this.scheduleUpdate=function(){return requestAnimationFrame(n.update)},this.update=oe(this.update.bind(this)),this.options=se({},t.Defaults,r),this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},this.reference=o.jquery?o[0]:o,this.popper=i.jquery?i[0]:i,this.options.modifiers={},Object.keys(se({},t.Defaults.modifiers,r.modifiers)).forEach(function(e){n.options.modifiers[e]=se({},t.Defaults.modifiers[e]||{},r.modifiers?r.modifiers[e]:{})}),this.modifiers=Object.keys(this.options.modifiers).map(function(e){return se({name:e},n.options.modifiers[e])}).sort(function(e,t){return e.order-t.order}),this.modifiers.forEach(function(t){t.enabled&&e(t.onLoad)&&t.onLoad(n.reference,n.popper,n.options,t,n.state)}),this.update();var p=this.options.eventsEnabled;p&&this.enableEventListeners(),this.state.eventsEnabled=p}return re(t,[{key:'update',value:function(){return k.call(this)}},{key:'destroy',value:function(){return D.call(this)}},{key:'enableEventListeners',value:function(){return A.call(this)}},{key:'disableEventListeners',value:function(){return I.call(this)}}]),t}();return le.Utils=('undefined'==typeof window?global:window).PopperUtils,le.placements=de,le.Defaults={placement:'bottom',eventsEnabled:!0,removeOnDestroy:!1,onCreate:function(){},onUpdate:function(){},modifiers:{shift:{order:100,enabled:!0,fn:function(e){var t=e.placement,o=t.split('-')[0],i=t.split('-')[1];if(i){var n=e.offsets,r=n.reference,p=n.popper,s=-1!==['bottom','top'].indexOf(o),d=s?'left':'top',a=s?'width':'height',f={start:pe({},d,r[d]),end:pe({},d,r[d]+r[a]-p[a])};e.offsets.popper=se({},p,f[i])}return e}},offset:{order:200,enabled:!0,fn:function(e,t){var o,i=t.offset,n=e.placement,r=e.offsets,p=r.popper,s=r.reference,d=n.split('-')[0];return o=R(+i)?[+i,0]:G(i,p,s,d),'left'===d?(p.top+=o[0],p.left-=o[1]):'right'===d?(p.top+=o[0],p.left+=o[1]):'top'===d?(p.left+=o[0],p.top-=o[1]):'bottom'===d&&(p.left+=o[0],p.top+=o[1]),e.popper=p,e},offset:0},preventOverflow:{order:300,enabled:!0,fn:function(e,t){var o=t.boundariesElement||r(e.instance.popper);e.instance.reference===o&&(o=r(o));var i=w(e.instance.popper,e.instance.reference,t.padding,o);t.boundaries=i;var n=t.priority,p=e.offsets.popper,s={primary:function(e){var o=p[e];return p[e]<i[e]&&!t.escapeWithReference&&(o=_(p[e],i[e])),pe({},e,o)},secondary:function(e){var o='right'===e?'left':'top',n=p[o];return p[e]>i[e]&&!t.escapeWithReference&&(n=z(p[o],i[e]-('right'===e?p.width:p.height))),pe({},o,n)}};return n.forEach(function(e){var t=-1===['left','top'].indexOf(e)?'secondary':'primary';p=se({},p,s[t](e))}),e.offsets.popper=p,e},priority:['left','right','top','bottom'],padding:5,boundariesElement:'scrollParent'},keepTogether:{order:400,enabled:!0,fn:function(e){var t=e.offsets,o=t.popper,i=t.reference,n=e.placement.split('-')[0],r=V,p=-1!==['top','bottom'].indexOf(n),s=p?'right':'bottom',d=p?'left':'top',a=p?'width':'height';return o[s]<r(i[d])&&(e.offsets.popper[d]=r(i[d])-o[a]),o[d]>r(i[s])&&(e.offsets.popper[d]=r(i[s])),e}},arrow:{order:500,enabled:!0,fn:function(e,t){if(!F(e.instance.modifiers,'arrow','keepTogether'))return e;var o=t.element;if('string'==typeof o){if(o=e.instance.popper.querySelector(o),!o)return e;}else if(!e.instance.popper.contains(o))return console.warn('WARNING: `arrow.element` must be child of its popper element!'),e;var i=e.placement.split('-')[0],n=e.offsets,r=n.popper,p=n.reference,s=-1!==['left','right'].indexOf(i),d=s?'height':'width',a=s?'top':'left',f=s?'left':'top',l=s?'bottom':'right',m=O(o)[d];p[l]-m<r[a]&&(e.offsets.popper[a]-=r[a]-(p[l]-m)),p[a]+m>r[l]&&(e.offsets.popper[a]+=p[a]+m-r[l]);var h=p[a]+p[d]/2-m/2,g=h-c(e.offsets.popper)[a];return g=_(z(r[d]-m,g),0),e.arrowElement=o,e.offsets.arrow={},e.offsets.arrow[a]=Math.round(g),e.offsets.arrow[f]='',e},element:'[x-arrow]'},flip:{order:600,enabled:!0,fn:function(e,t){if(W(e.instance.modifiers,'inner'))return e;if(e.flipped&&e.placement===e.originalPlacement)return e;var o=w(e.instance.popper,e.instance.reference,t.padding,t.boundariesElement),i=e.placement.split('-')[0],n=L(i),r=e.placement.split('-')[1]||'',p=[];switch(t.behavior){case fe.FLIP:p=[i,n];break;case fe.CLOCKWISE:p=K(i);break;case fe.COUNTERCLOCKWISE:p=K(i,!0);break;default:p=t.behavior;}return p.forEach(function(s,d){if(i!==s||p.length===d+1)return e;i=e.placement.split('-')[0],n=L(i);var a=e.offsets.popper,f=e.offsets.reference,l=V,m='left'===i&&l(a.right)>l(f.left)||'right'===i&&l(a.left)<l(f.right)||'top'===i&&l(a.bottom)>l(f.top)||'bottom'===i&&l(a.top)<l(f.bottom),h=l(a.left)<l(o.left),c=l(a.right)>l(o.right),g=l(a.top)<l(o.top),u=l(a.bottom)>l(o.bottom),b='left'===i&&h||'right'===i&&c||'top'===i&&g||'bottom'===i&&u,y=-1!==['top','bottom'].indexOf(i),w=!!t.flipVariations&&(y&&'start'===r&&h||y&&'end'===r&&c||!y&&'start'===r&&g||!y&&'end'===r&&u);(m||b||w)&&(e.flipped=!0,(m||b)&&(i=p[d+1]),w&&(r=j(r)),e.placement=i+(r?'-'+r:''),e.offsets.popper=se({},e.offsets.popper,S(e.instance.popper,e.offsets.reference,e.placement)),e=N(e.instance.modifiers,e,'flip'))}),e},behavior:'flip',padding:5,boundariesElement:'viewport'},inner:{order:700,enabled:!1,fn:function(e){var t=e.placement,o=t.split('-')[0],i=e.offsets,n=i.popper,r=i.reference,p=-1!==['left','right'].indexOf(o),s=-1===['top','left'].indexOf(o);return n[p?'left':'top']=r[t]-(s?n[p?'width':'height']:0),e.placement=L(t),e.offsets.popper=c(n),e}},hide:{order:800,enabled:!0,fn:function(e){if(!F(e.instance.modifiers,'hide','preventOverflow'))return e;var t=e.offsets.reference,o=T(e.instance.modifiers,function(e){return'preventOverflow'===e.name}).boundaries;if(t.bottom<o.top||t.left>o.right||t.top>o.bottom||t.right<o.left){if(!0===e.hide)return e;e.hide=!0,e.attributes['x-out-of-boundaries']=''}else{if(!1===e.hide)return e;e.hide=!1,e.attributes['x-out-of-boundaries']=!1}return e}},computeStyle:{order:850,enabled:!0,fn:function(e,t){var o=t.x,i=t.y,n=e.offsets.popper,p=T(e.instance.modifiers,function(e){return'applyStyle'===e.name}).gpuAcceleration;void 0!==p&&console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');var s,d,a=void 0===p?t.gpuAcceleration:p,f=r(e.instance.popper),l=g(f),m={position:n.position},h={left:V(n.left),top:V(n.top),bottom:V(n.bottom),right:V(n.right)},c='bottom'===o?'top':'bottom',u='right'===i?'left':'right',b=B('transform');if(d='bottom'==c?-l.height+h.bottom:h.top,s='right'==u?-l.width+h.right:h.left,a&&b)m[b]='translate3d('+s+'px, '+d+'px, 0)',m[c]=0,m[u]=0,m.willChange='transform';else{var y='bottom'==c?-1:1,w='right'==u?-1:1;m[c]=d*y,m[u]=s*w,m.willChange=c+', '+u}var v={\"x-placement\":e.placement};return e.attributes=se({},v,e.attributes),e.styles=se({},m,e.styles),e},gpuAcceleration:!0,x:'bottom',y:'right'},applyStyle:{order:900,enabled:!0,fn:function(e){return U(e.instance.popper,e.styles),Y(e.instance.popper,e.attributes),e.offsets.arrow&&U(e.arrowElement,e.offsets.arrow),e},onLoad:function(e,t,o,i,n){var r=x(n,t,e),p=E(o.placement,r,t,e,o.modifiers.flip.boundariesElement,o.modifiers.flip.padding);return t.setAttribute('x-placement',p),U(t,{position:'absolute'}),o},gpuAcceleration:void 0}}},le});\r\n//# sourceMappingURL=popper.min.js.map","/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nexport default function isFunction(functionToCheck) {\n  const getType = {};\n  return (\n    functionToCheck &&\n    getType.toString.call(functionToCheck) === '[object Function]'\n  );\n}\n","/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nexport default function getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nexport default function getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getParentNode from './getParentNode';\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nexport default function getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (\n    !element ||\n    ['HTML', 'BODY', '#document'].indexOf(element.nodeName) !== -1\n  ) {\n    return window.document.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n  if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nexport default function getOffsetParent(element) {\n  // NOTE: 1 DOM access here\n  const offsetParent = element && element.offsetParent;\n  const nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return window.document.documentElement;\n  }\n\n  // .offsetParent will return the closest TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (\n    ['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent, 'position') === 'static'\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n","import getOffsetParent from './getOffsetParent';\n\nexport default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return (\n    nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import isOffsetContainer from './isOffsetContainer';\nimport getRoot from './getRoot';\nimport getOffsetParent from './getOffsetParent';\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nexport default function findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return window.document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  const order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  // Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  // Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  ) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nexport default function getScroll(element, side = 'top') {\n  const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  const nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    const html = window.document.documentElement;\n    const scrollingElement = window.document.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import getScroll from './getScroll';\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nexport default function includeScroll(rect, element, subtract = false) {\n  const scrollTop = getScroll(element, 'top');\n  const scrollLeft = getScroll(element, 'left');\n  const modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles, axis) {\n  const sideA = axis === 'x' ? 'Left' : 'Top';\n  const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return (\n    +styles[`border${sideA}Width`].split('px')[0] +\n    +styles[`border${sideB}Width`].split('px')[0]\n  );\n}\n","import isIE10 from './isIE10';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE10()\n      ? html[`offset${axis}`] +\n        computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`] +\n        computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`]\n      : 0\n  );\n}\n\nexport default function getWindowSizes() {\n  const body = window.document.body;\n  const html = window.document.documentElement;\n  const computedStyle = isIE10() && window.getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getBordersSize from './getBordersSize';\nimport getWindowSizes from './getWindowSizes';\nimport getScroll from './getScroll';\nimport getClientRect from './getClientRect';\nimport isIE10 from './isIE10';\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nexport default function getBoundingClientRect(element) {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  if (isIE10()) {\n    try {\n      rect = element.getBoundingClientRect();\n      const scrollTop = getScroll(element, 'top');\n      const scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } catch (err) {}\n  } else {\n    rect = element.getBoundingClientRect();\n  }\n\n  const result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};\n  const width =\n    sizes.width || element.clientWidth || result.right - result.left;\n  const height =\n    sizes.height || element.clientHeight || result.bottom - result.top;\n\n  let horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport includeScroll from './includeScroll';\nimport getScrollParent from './getScrollParent';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport runIsIE10 from './isIE10';\nimport getClientRect from './getClientRect';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children, parent) {\n  const isIE10 = runIsIE10();\n  const isHTML = parent.nodeName === 'HTML';\n  const childrenRect = getBoundingClientRect(children);\n  const parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const styles = getStyleComputedProperty(parent);\n  const borderTopWidth = +styles.borderTopWidth.split('px')[0];\n  const borderLeftWidth = +styles.borderLeftWidth.split('px')[0];\n\n  let offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const marginTop = +styles.marginTop.split('px')[0];\n    const marginLeft = +styles.marginLeft.split('px')[0];\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10\n      ? parent.contains(scrollParent)\n      : parent === scrollParent && scrollParent.nodeName !== 'BODY'\n  ) {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode';\nimport getScroll from './getScroll';\nimport getClientRect from './getClientRect';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  const html = window.document.documentElement;\n  const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = getScroll(html);\n  const scrollLeft = getScroll(html, 'left');\n\n  const offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return getClientRect(offset);\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getParentNode from './getParentNode';\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element) {\n  const nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  return isFixed(getParentNode(element));\n}\n","import getScrollParent from './getScrollParent';\nimport getParentNode from './getParentNode';\nimport findCommonOffsetParent from './findCommonOffsetParent';\nimport getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode';\nimport getViewportOffsetRectRelativeToArtbitraryNode from './getViewportOffsetRectRelativeToArtbitraryNode';\nimport getWindowSizes from './getWindowSizes';\nimport isFixed from './isFixed';\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @returns {Object} Coordinates of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement\n) {\n  // NOTE: 1 DOM access here\n  let boundaries = { top: 0, left: 0 };\n  const offsetParent = findCommonOffsetParent(popper, reference);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    let boundariesNode;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(popper));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = window.document.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = window.document.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent\n    );\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes();\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n\n  return boundaries;\n}\n","import getBoundaries from '../utils/getBoundaries';\n\nfunction getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding = 0\n) {\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  const boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area: getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >= popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? `-${variation}` : '');\n}\n","import findCommonOffsetParent from './findCommonOffsetParent';\nimport getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode';\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nexport default function getReferenceOffsets(state, popper, reference) {\n  const commonOffsetParent = findCommonOffsetParent(popper, reference);\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);\n}\n","/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nexport default function getOuterSizes(element) {\n  const styles = window.getComputedStyle(element);\n  const x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n  const y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n  const result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x,\n  };\n  return result;\n}\n","/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nexport default function getOppositePlacement(placement) {\n  const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n","import getOuterSizes from './getOuterSizes';\nimport getOppositePlacement from './getOppositePlacement';\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nexport default function getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  const popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  const popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height,\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  const mainSide = isHoriz ? 'top' : 'left';\n  const secondarySide = isHoriz ? 'left' : 'top';\n  const measurement = isHoriz ? 'height' : 'width';\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide] +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n","/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nexport default function find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n","import find from './find';\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nexport default function findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(cur => cur[prop] === value);\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  const match = find(arr, obj => obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import isFunction from './isFunction';\nimport findIndex from './findIndex';\nimport getClientRect from '../utils/getClientRect';\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nexport default function runModifiers(modifiers, data, ends) {\n  const modifiersToRun = ends === undefined\n    ? modifiers\n    : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(modifier => {\n    if (modifier.function) {\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    const fn = modifier.function || modifier.fn;\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n","import computeAutoPlacement from '../utils/computeAutoPlacement';\nimport getReferenceOffsets from '../utils/getReferenceOffsets';\nimport getPopperOffsets from '../utils/getPopperOffsets';\nimport runModifiers from '../utils/runModifiers';\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nexport default function update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  let data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {},\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(\n    this.state,\n    this.popper,\n    this.reference\n  );\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(\n    this.options.placement,\n    data.offsets.reference,\n    this.popper,\n    this.reference,\n    this.options.modifiers.flip.boundariesElement,\n    this.options.modifiers.flip.padding\n  );\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(\n    this.popper,\n    data.offsets.reference,\n    data.placement\n  );\n  data.offsets.popper.position = 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n","/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nexport default function isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(\n    ({ name, enabled }) => enabled && name === modifierName\n  );\n}\n","/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default function getSupportedPropertyName(property) {\n  const prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  const upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (let i = 0; i < prefixes.length - 1; i++) {\n    const prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` : property;\n    if (typeof window.document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n","import isModifierEnabled from '../utils/isModifierEnabled';\nimport getSupportedPropertyName from '../utils/getSupportedPropertyName';\n\n/**\n * Destroy the popper\n * @method\n * @memberof Popper\n */\nexport default function destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.left = '';\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicity asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n","import getScrollParent from './getScrollParent';\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  const isBody = scrollParent.nodeName === 'BODY';\n  const target = isBody ? window : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  window.addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    'scroll',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","import setupEventListeners from '../utils/setupEventListeners';\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nexport default function enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(\n      this.reference,\n      this.options,\n      this.state,\n      this.scheduleUpdate\n    );\n  }\n}\n","/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport default function removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  window.removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target => {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import removeEventListeners from '../utils/removeEventListeners';\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger onUpdate callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nexport default function disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    window.cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n","/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","import isNumeric from './isNumeric';\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nexport default function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (\n      ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n","/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nexport default function setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function(prop) {\n    const value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","import find from './find';\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nexport default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n) {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested} modifier is required by ${requesting} modifier in order to work, be sure to include it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nexport default function getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n","import placements from '../methods/placements';\n\n// Get rid of `auto` `auto-start` and `auto-end`\nconst validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nexport default function clockwise(placement, counter = false) {\n  const index = validPlacements.indexOf(placement);\n  const arr = validPlacements\n    .slice(index + 1)\n    .concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n","import isNumeric from '../utils/isNumeric';\nimport getClientRect from '../utils/getClientRect';\nimport find from '../utils/find';\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nexport function toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  const split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  const value = +split[1];\n  const unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    let element;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    const rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    let size;\n    if (unit === 'vh') {\n      size = Math.max(\n        document.documentElement.clientHeight,\n        window.innerHeight || 0\n      );\n    } else {\n      size = Math.max(\n        document.documentElement.clientWidth,\n        window.innerWidth || 0\n      );\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nexport function parseOffset(\n  offset,\n  popperOffsets,\n  referenceOffsets,\n  basePlacement\n) {\n  const offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  const useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  const fragments = offset.split(/(\\+|\\-)/).map(frag => frag.trim());\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  const divider = fragments.indexOf(\n    find(fragments, frag => frag.search(/,|\\s/) !== -1)\n  );\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn(\n      'Offsets separated by white space(s) are deprecated, use a comma (,) instead.'\n    );\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  const splitRegex = /\\s*,\\s*|\\s+/;\n  let ops = divider !== -1\n    ? [\n        fragments\n          .slice(0, divider)\n          .concat([fragments[divider].split(splitRegex)[0]]),\n        [fragments[divider].split(splitRegex)[1]].concat(\n          fragments.slice(divider + 1)\n        ),\n      ]\n    : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map((op, index) => {\n    // Most of the units rely on the orientation of the popper\n    const measurement = (index === 1 ? !useHeight : useHeight)\n      ? 'height'\n      : 'width';\n    let mergeWithPrevious = false;\n    return (\n      op\n        // This aggregates any `+` or `-` sign that aren't considered operators\n        // e.g.: 10 + +5 => [10, +, +5]\n        .reduce((a, b) => {\n          if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n            a[a.length - 1] = b;\n            mergeWithPrevious = true;\n            return a;\n          } else if (mergeWithPrevious) {\n            a[a.length - 1] += b;\n            mergeWithPrevious = false;\n            return a;\n          } else {\n            return a.concat(b);\n          }\n        }, [])\n        // Here we convert the string values into number values (in px)\n        .map(str => toValue(str, measurement, popperOffsets, referenceOffsets))\n    );\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach((op, index) => {\n    op.forEach((frag, index2) => {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nexport default function offset(data, { offset }) {\n  const { placement, offsets: { popper, reference } } = data;\n  const basePlacement = placement.split('-')[0];\n\n  let offsets;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n","import isNative from './isNative';\n\nconst isBrowser = typeof window !== 'undefined';\nconst longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nlet timeoutDuration = 0;\nfor (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n    timeoutDuration = 1;\n    break;\n  }\n}\n\nexport function microtaskDebounce(fn) {\n  let scheduled = false;\n  let i = 0;\n  const elem = document.createElement('span');\n\n  // MutationObserver provides a mechanism for scheduling microtasks, which\n  // are scheduled *before* the next task. This gives us a way to debounce\n  // a function but ensure it's called *before* the next paint.\n  const observer = new MutationObserver(() => {\n    fn();\n    scheduled = false;\n  });\n\n  observer.observe(elem, { attributes: true });\n\n  return () => {\n    if (!scheduled) {\n      scheduled = true;\n      elem.setAttribute('x-index', i);\n      i = i + 1; // don't use compund (+=) because it doesn't get optimized in V8\n    }\n  };\n}\n\nexport function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\n// It's common for MutationObserver polyfills to be seen in the wild, however\n// these rely on Mutation Events which only occur when an element is connected\n// to the DOM. The algorithm used in this module does not use a connected element,\n// and so we must ensure that a *native* MutationObserver is available.\nconst supportsNativeMutationObserver =\n  isBrowser && isNative(window.MutationObserver);\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport default (supportsNativeMutationObserver\n  ? microtaskDebounce\n  : taskDebounce);\n","import getClientRect from '../utils/getClientRect';\nimport getOuterSizes from '../utils/getOuterSizes';\nimport isModifierRequired from '../utils/isModifierRequired';\nimport getStyleComputedProperty from '../utils/getStyleComputedProperty';\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function arrow(data, options) {\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  let arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn(\n        'WARNING: `arrow.element` must be child of its popper element!'\n      );\n      return data;\n    }\n  }\n\n  const placement = data.placement.split('-')[0];\n  const { popper, reference } = data.offsets;\n  const isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  const len = isVertical ? 'height' : 'width';\n  const sideCapitalized = isVertical ? 'Top' : 'Left';\n  const side = sideCapitalized.toLowerCase();\n  const altSide = isVertical ? 'left' : 'top';\n  const opSide = isVertical ? 'bottom' : 'right';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjuction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -=\n      popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] +=\n      reference[side] + arrowElementSize - popper[opSide];\n  }\n\n  // compute center of the popper\n  const center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  const popperMarginSide = getStyleComputedProperty(\n    data.instance.popper,\n    `margin${sideCapitalized}`\n  ).replace('px', '');\n  let sideValue =\n    center - getClientRect(data.offsets.popper)[side] - popperMarginSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = {};\n  data.offsets.arrow[side] = Math.round(sideValue);\n  data.offsets.arrow[altSide] = ''; // make sure to unset any eventual altSide value from the DOM node\n\n  return data;\n}\n","import getSupportedPropertyName from '../utils/getSupportedPropertyName';\nimport find from '../utils/find';\nimport getOffsetParent from '../utils/getOffsetParent';\nimport getBoundingClientRect from '../utils/getBoundingClientRect';\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function computeStyle(data, options) {\n  const { x, y } = options;\n  const { popper } = data.offsets;\n\n  // Remove this legacy support in Popper.js v2\n  const legacyGpuAccelerationOption = find(\n    data.instance.modifiers,\n    modifier => modifier.name === 'applyStyle'\n  ).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn(\n      'WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'\n    );\n  }\n  const gpuAcceleration =\n    legacyGpuAccelerationOption !== undefined\n      ? legacyGpuAccelerationOption\n      : options.gpuAcceleration;\n\n  const offsetParent = getOffsetParent(data.instance.popper);\n  const offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  const styles = {\n    position: popper.position,\n  };\n\n  // floor sides to avoid blurry text\n  const offsets = {\n    left: Math.floor(popper.left),\n    top: Math.floor(popper.top),\n    bottom: Math.floor(popper.bottom),\n    right: Math.floor(popper.right),\n  };\n\n  const sideA = x === 'bottom' ? 'top' : 'bottom';\n  const sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  const prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  let left, top;\n  if (sideA === 'bottom') {\n    top = -offsetParentRect.height + offsets.bottom;\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    left = -offsetParentRect.width + offsets.right;\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = `translate3d(${left}px, ${top}px, 0)`;\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    const invertTop = sideA === 'bottom' ? -1 : 1;\n    const invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = `${sideA}, ${sideB}`;\n  }\n\n  // Attributes\n  const attributes = {\n    'x-placement': data.placement,\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = { ...attributes, ...data.attributes };\n  data.styles = { ...styles, ...data.styles };\n  data.arrowStyles = { ...data.offsets.arrow, ...data.arrowStyles };\n\n  return data;\n}\n","const nativeHints = [\n  'native code',\n  '[object MutationObserverConstructor]', // for mobile safari iOS 9.0\n];\n\n/**\n * Determine if a function is implemented natively (as opposed to a polyfill).\n * @method\n * @memberof Popper.Utils\n * @argument {Function | undefined} fn the function to check\n * @returns {Boolean}\n */\nexport default fn =>\n  nativeHints.some(hint => (fn || '').toString().indexOf(hint) > -1);\n","/**\n * Tells if you are running Internet Explorer 10\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean} isIE10\n */\nlet isIE10 = undefined;\n\nexport default function() {\n  if (isIE10 === undefined) {\n    isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;\n  }\n  return isIE10;\n}\n","import getOppositePlacement from '../utils/getOppositePlacement';\nimport getOppositeVariation from '../utils/getOppositeVariation';\nimport getPopperOffsets from '../utils/getPopperOffsets';\nimport runModifiers from '../utils/runModifiers';\nimport getBoundaries from '../utils/getBoundaries';\nimport isModifierEnabled from '../utils/isModifierEnabled';\nimport clockwise from '../utils/clockwise';\n\nconst BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise',\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  const boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    options.boundariesElement\n  );\n\n  let placement = data.placement.split('-')[0];\n  let placementOpposite = getOppositePlacement(placement);\n  let variation = data.placement.split('-')[1] || '';\n\n  let flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach((step, index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    const popperOffsets = data.offsets.popper;\n    const refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    const floor = Math.floor;\n    const overlapsRef =\n      (placement === 'left' &&\n        floor(popperOffsets.right) > floor(refOffsets.left)) ||\n      (placement === 'right' &&\n        floor(popperOffsets.left) < floor(refOffsets.right)) ||\n      (placement === 'top' &&\n        floor(popperOffsets.bottom) > floor(refOffsets.top)) ||\n      (placement === 'bottom' &&\n        floor(popperOffsets.top) < floor(refOffsets.bottom));\n\n    const overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    const overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    const overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    const overflowsBottom =\n      floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    const overflowsBoundaries =\n      (placement === 'left' && overflowsLeft) ||\n      (placement === 'right' && overflowsRight) ||\n      (placement === 'top' && overflowsTop) ||\n      (placement === 'bottom' && overflowsBottom);\n\n    // flip the variation if required\n    const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    const flippedVariation =\n      !!options.flipVariations &&\n      ((isVertical && variation === 'start' && overflowsLeft) ||\n        (isVertical && variation === 'end' && overflowsRight) ||\n        (!isVertical && variation === 'start' && overflowsTop) ||\n        (!isVertical && variation === 'end' && overflowsBottom));\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = {\n        ...data.offsets.popper,\n        ...getPopperOffsets(\n          data.instance.popper,\n          data.offsets.reference,\n          data.placement\n        ),\n      };\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n","// Utils\nimport debounce from './utils/debounce';\nimport isFunction from './utils/isFunction';\n\n// Methods\nimport update from './methods/update';\nimport destroy from './methods/destroy';\nimport enableEventListeners from './methods/enableEventListeners';\nimport disableEventListeners from './methods/disableEventListeners';\nimport Defaults from './methods/defaults';\nimport placements from './methods/placements';\n\nexport default class Popper {\n  /**\n   * Create a new Popper.js instance\n   * @class Popper\n   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper.\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  constructor(reference, popper, options = {}) {\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = { ...Popper.Defaults, ...options };\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: [],\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference.jquery ? reference[0] : reference;\n    this.popper = popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys({\n      ...Popper.Defaults.modifiers,\n      ...options.modifiers,\n    }).forEach(name => {\n      this.options.modifiers[name] = {\n        // If it's a built-in modifier, use it as base\n        ...(Popper.Defaults.modifiers[name] || {}),\n        // If there are custom options, override and merge with default ones\n        ...(options.modifiers ? options.modifiers[name] : {}),\n      };\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers)\n      .map(name => ({\n        name,\n        ...this.options.modifiers[name],\n      }))\n      // sort the modifiers by order\n      .sort((a, b) => a.order - b.order);\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(modifierOptions => {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(\n          this.reference,\n          this.popper,\n          this.options,\n          modifierOptions,\n          this.state\n        );\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    const eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n  update() {\n    return update.call(this);\n  }\n  destroy() {\n    return destroy.call(this);\n  }\n  enableEventListeners() {\n    return enableEventListeners.call(this);\n  }\n  disableEventListeners() {\n    return disableEventListeners.call(this);\n  }\n\n  /**\n   * Schedule an update, it will run on the next UI update available\n   * @method scheduleUpdate\n   * @memberof Popper\n   */\n  scheduleUpdate = () => requestAnimationFrame(this.update);\n\n  /**\n   * Collection of utilities useful when writing custom modifiers.\n   * Starting from version 1.7, this method is available only if you\n   * include `popper-utils.js` before `popper.js`.\n   *\n   * **DEPRECATION**: This way to access PopperUtils is deprecated\n   * and will be removed in v2! Use the PopperUtils module directly instead.\n   * Due to the high instability of the methods contained in Utils, we can't\n   * guarantee them to follow semver. Use them at your own risk!\n   * @static\n   * @private\n   * @type {Object}\n   * @deprecated since version 1.8\n   * @member Utils\n   * @memberof Popper\n   */\n  static Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;\n\n  static placements = placements;\n\n  static Defaults = Defaults;\n}\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n","import modifiers from '../modifiers/index';\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overriden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass as 3rd argument an object with the same\n * structure of this object, example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nexport default {\n  /**\n   * Popper's placement\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Whether events (resize, scroll) are initially enabled\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: () => {},\n\n  /**\n   * Callback called when the popper is updated, this callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: () => {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js\n   * @prop {modifiers}\n   */\n  modifiers,\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n","import applyStyle, { applyStyleOnLoad } from './applyStyle';\nimport computeStyle from './computeStyle';\nimport arrow from './arrow';\nimport flip from './flip';\nimport keepTogether from './keepTogether';\nimport offset from './offset';\nimport preventOverflow from './preventOverflow';\nimport shift from './shift';\nimport hide from './hide';\nimport inner from './inner';\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nexport default {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift,\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unitless, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the height.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0,\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * An scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\" — or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper this makes sure the popper has always a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier, can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent',\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near eachothers\n   * without leaving any gap between the two. Expecially useful when the arrow is\n   * enabled and you want to assure it to point to its reference element.\n   * It cares only about the first axis, you can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether,\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjuction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]',\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations).\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position,\n     * the popper will never be placed outside of the defined boundaries\n     * (except if keepTogether is enabled)\n     */\n    boundariesElement: 'viewport',\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner,\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide,\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right',\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define you own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: undefined,\n  },\n};\n\n/**\n * The `dataObject` is an object containing all the informations used by Popper.js\n * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n","/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function shift(data) {\n  const placement = data.placement;\n  const basePlacement = placement.split('-')[0];\n  const shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    const { reference, popper } = data.offsets;\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n\n    const shiftOffsets = {\n      start: { [side]: reference[side] },\n      end: {\n        [side]: reference[side] + reference[measurement] - popper[measurement],\n      },\n    };\n\n    data.offsets.popper = { ...popper, ...shiftOffsets[shiftvariation] };\n  }\n\n  return data;\n}\n","import getOffsetParent from '../utils/getOffsetParent';\nimport getBoundaries from '../utils/getBoundaries';\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function preventOverflow(data, options) {\n  let boundariesElement =\n    options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  const boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    boundariesElement\n  );\n  options.boundaries = boundaries;\n\n  const order = options.priority;\n  let popper = data.offsets.popper;\n\n  const check = {\n    primary(placement) {\n      let value = popper[placement];\n      if (\n        popper[placement] < boundaries[placement] &&\n        !options.escapeWithReference\n      ) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return { [placement]: value };\n    },\n    secondary(placement) {\n      const mainSide = placement === 'right' ? 'left' : 'top';\n      let value = popper[mainSide];\n      if (\n        popper[placement] > boundaries[placement] &&\n        !options.escapeWithReference\n      ) {\n        value = Math.min(\n          popper[mainSide],\n          boundaries[placement] -\n            (placement === 'right' ? popper.width : popper.height)\n        );\n      }\n      return { [mainSide]: value };\n    },\n  };\n\n  order.forEach(placement => {\n    const side = ['left', 'top'].indexOf(placement) !== -1\n      ? 'primary'\n      : 'secondary';\n    popper = { ...popper, ...check[side](placement) };\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n","/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function keepTogether(data) {\n  const { popper, reference } = data.offsets;\n  const placement = data.placement.split('-')[0];\n  const floor = Math.floor;\n  const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  const side = isVertical ? 'right' : 'bottom';\n  const opSide = isVertical ? 'left' : 'top';\n  const measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] =\n      floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n","import getClientRect from '../utils/getClientRect';\nimport getOppositePlacement from '../utils/getOppositePlacement';\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function inner(data) {\n  const placement = data.placement;\n  const basePlacement = placement.split('-')[0];\n  const { popper, reference } = data.offsets;\n  const isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  const subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] =\n    reference[basePlacement] -\n    (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n","import isModifierRequired from '../utils/isModifierRequired';\nimport find from '../utils/find';\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  const refRect = data.offsets.reference;\n  const bound = find(\n    data.instance.modifiers,\n    modifier => modifier.name === 'preventOverflow'\n  ).boundaries;\n\n  if (\n    refRect.bottom < bound.top ||\n    refRect.left > bound.right ||\n    refRect.top > bound.bottom ||\n    refRect.right < bound.left\n  ) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n","import setStyles from '../utils/setStyles';\nimport setAttributes from '../utils/setAttributes';\nimport getReferenceOffsets from '../utils/getReferenceOffsets';\nimport computeAutoPlacement from '../utils/computeAutoPlacement';\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nexport default function applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper.\n * @param {Object} options - Popper.js options\n */\nexport function applyStyleOnLoad(\n  reference,\n  popper,\n  options,\n  modifierOptions,\n  state\n) {\n  // compute reference element offsets\n  const referenceOffsets = getReferenceOffsets(state, popper, reference);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  const placement = computeAutoPlacement(\n    options.placement,\n    referenceOffsets,\n    popper,\n    reference,\n    options.modifiers.flip.boundariesElement,\n    options.modifiers.flip.padding\n  );\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: 'absolute' });\n\n  return options;\n}\n"],"names":["t","e","toString","call","nodeType","o","window","getComputedStyle","nodeName","parentNode","host","n","indexOf","document","body","i","r","overflow","p","overflowX","s","overflowY","test","offsetParent","documentElement","d","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","a","createRange","setStart","setEnd","f","commonAncestorContainer","contains","firstElementChild","l","arguments","length","scrollingElement","split","m","_","ie","h","height","width","c","se","right","left","bottom","top","g","getBoundingClientRect","clientWidth","clientHeight","offsetWidth","offsetHeight","u","borderTopWidth","borderLeftWidth","marginTop","marginLeft","b","w","innerWidth","innerHeight","y","E","Object","keys","map","key","area","sort","filter","x","O","parseFloat","marginBottom","marginRight","L","replace","S","T","Array","prototype","find","N","slice","C","findIndex","forEach","function","console","warn","fn","enabled","offsets","popper","reference","k","state","isDestroyed","instance","styles","attributes","flipped","placement","options","modifiers","flip","boundariesElement","padding","originalPlacement","position","isCreated","onUpdate","onCreate","W","some","name","B","charAt","toUpperCase","style","D","removeAttribute","disableEventListeners","removeOnDestroy","removeChild","A","eventsEnabled","scheduleUpdate","updateBound","addEventListener","passive","H","push","scrollParents","scrollElement","I","cancelAnimationFrame","removeEventListener","R","isNaN","isFinite","U","F","order","K","ae","concat","reverse","z","Math","min","V","floor","max","J","Z","$","ee","navigator","userAgent","oe","te","MutationObserver","X","createElement","observe","setAttribute","setTimeout","appVersion","ne","TypeError","re","enumerable","configurable","writable","defineProperty","pe","value","assign","hasOwnProperty","de","fe","FLIP","CLOCKWISE","COUNTERCLOCKWISE","le","requestAnimationFrame","update","bind","Defaults","jquery","onLoad","enableEventListeners","Utils","global","PopperUtils","placements","shift","start","end","offset","trim","search","reduce","match","preventOverflow","boundaries","priority","primary","escapeWithReference","secondary","keepTogether","arrow","element","querySelector","arrowElement","round","behavior","flipVariations","inner","hide","computeStyle","gpuAcceleration","willChange","v","applyStyle","Y","exports","module","define","amd","Popper","functionToCheck","getType","css","property","getStyleComputedProperty","getScrollParent","getParentNode","getOffsetParent","node","getRoot","element1","element2","range","isOffsetContainer","element1root","findCommonOffsetParent","side","upperSide","html","subtract","scrollTop","getScroll","scrollLeft","modifier","sideA","axis","sideB","isIE10","computedStyle","getSize","rect","result","sizes","getWindowSizes","horizScrollbar","vertScrollbar","getBordersSize","getClientRect","runIsIE10","isHTML","parent","childrenRect","parentRect","scrollParent","includeScroll","relativeOffset","getOffsetRectRelativeToArbitraryNode","isFixed","getViewportOffsetRectRelativeToArtbitraryNode","boundariesNode","getBoundaries","rects","refRect","sortedAreas","getArea","filteredAreas","computedPlacement","variation","commonOffsetParent","hash","popperRect","getOuterSizes","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","referenceOffsets","getOppositePlacement","arr","cur","obj","modifiersToRun","ends","isFunction","data","getReferenceOffsets","computeAutoPlacement","getPopperOffsets","runModifiers","prefixes","upperProp","prefix","toCheck","isModifierEnabled","getSupportedPropertyName","isBody","target","setupEventListeners","removeEventListeners","unit","isNumeric","requesting","isRequired","requested","counter","index","validPlacements","str","size","useHeight","fragments","frag","divider","splitRegex","ops","mergeWithPrevious","op","toValue","index2","basePlacement","parseOffset","nativeHints","isBrowser","longerTimeoutBrowsers","timeoutDuration","supportsNativeMutationObserver","isNative","scheduled","elem","observer","BEHAVIORS","debounce","modifierOptions","destroy","shiftvariation","isVertical","shiftOffsets","check","opSide","isModifierRequired","len","sideCapitalized","toLowerCase","altSide","arrowElementSize","center","popperMarginSide","sideValue","placementOpposite","flipOrder","clockwise","refOffsets","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","getOppositeVariation","subtractLength","bound","legacyGpuAccelerationOption","offsetParentRect","prefixedProperty","invertTop","invertLeft","arrowStyles"],"version":3,"file":"index.eab6e18b.js.map"}